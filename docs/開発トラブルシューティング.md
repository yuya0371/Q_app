# 開発トラブルシューティング

開発中に発生した問題とその解決方法をまとめたドキュメントです。

---

## 目次

1. [SecureStore 2048バイト制限](#1-securestore-2048バイト制限)
2. [HTTPメソッドの不一致（PATCH vs PUT）](#2-httpメソッドの不一致patch-vs-put)
3. [API Gatewayルート定義順序](#3-api-gatewayルート定義順序)
4. [App ID設定APIの未実装](#4-app-id設定apiの未実装)
5. [Cognito AuthorizerのToken種類](#5-cognito-authorizerのtoken種類)
6. [DynamoDB GSI名・属性名の不一致](#6-dynamodb-gsi名属性名の不一致)
7. [queryItems関数がCOUNTに非対応](#7-queryitems関数がcountに非対応)
8. [APIレスポンス形式の不一致](#8-apiレスポンス形式の不一致)
9. [S3バケットのパブリックアクセス設定](#9-s3バケットのパブリックアクセス設定)
10. [プロフィール画像削除APIの未実装](#10-プロフィール画像削除apiの未実装)
11. [管理画面ログインAPIのレスポンス形式](#11-管理画面ログインapiのレスポンス形式)
12. [管理画面APIレスポンス形式の不統一](#12-管理画面apiレスポンス形式の不統一)
13. [NGワードテーブルのキースキーマ](#13-ngワードテーブルのキースキーマ)
14. [URLエンコーディング（日本語対応）](#14-urlエンコーディング日本語対応)
15. [質問公開時刻が要件と異なる（固定時刻になっていた）](#15-質問公開時刻が要件と異なる固定時刻になっていた)

---

## 1. SecureStore 2048バイト制限

### 発生日
2026-02-04

### 症状
- アプリ起動時に警告が表示される
- 認証状態が正しく永続化されない場合がある

### エラーメッセージ
```
WARN  SecureStore: Value being stored is too large (3xxx bytes). Values larger than 2048 bytes may not be stored successfully.
```

### 原因
- Expo SecureStoreには2048バイトの制限がある
- CognitoのJWTトークン（特にID Token）は2048バイトを超えることが多い
- zustand/persistでSecureStoreを使用していたため、トークンが正しく保存できなかった

### 解決方法
`authStore.ts`でSecureStoreからAsyncStorageに変更

```typescript
// 変更前
import * as SecureStore from 'expo-secure-store';

// 変更後
import AsyncStorage from '@react-native-async-storage/async-storage';

const asyncStorage = {
  getItem: async (name: string): Promise<string | null> => {
    return await AsyncStorage.getItem(name);
  },
  setItem: async (name: string, value: string): Promise<void> => {
    await AsyncStorage.setItem(name, value);
  },
  removeItem: async (name: string): Promise<void> => {
    await AsyncStorage.removeItem(name);
  },
};
```

### 備考
- JWTは署名されているため、改ざん検知は可能
- 高いセキュリティが必要な場合は、トークンの暗号化を検討

---

## 2. HTTPメソッドの不一致（PATCH vs PUT）

### 発生日
2026-02-04

### 症状
- プロフィール更新時に403 Forbiddenエラー

### エラーメッセージ
```
AxiosError: Request failed with status code 403
この操作を行う権限がありません。
```

### 原因
- フロントエンド: `PATCH /users/me`でリクエスト
- バックエンド（API Gateway）: `PUT /users/me`で定義
- メソッドが一致しないため、403エラーが発生

### 解決方法
`useUsers.ts`でPATCHからPUTに変更

```typescript
// 変更前
const response = await apiClient.patch<UpdateProfileResponse>('/users/me', data);

// 変更後
const response = await apiClient.put<UpdateProfileResponse>('/users/me', data);
```

### 教訓
- API設計書とフロントエンド実装のHTTPメソッドを常に一致させる
- API設計書を更新した際は、フロントエンドも確認する

---

## 3. API Gatewayルート定義順序

### 発生日
2026-02-05

### 症状
- `PUT /users/me`が403 Forbiddenを返す
- Lambda関数に到達しない

### 原因
API Gatewayでは、パス変数（`{userId}`）と固定パス（`me`）がある場合、**固定パスを先に定義する必要がある**。

```typescript
// 問題のあるコード（api-stack.ts）
const userByIdResource = usersResource.addResource('{userId}');  // 先に定義
const meResource = usersResource.addResource('me');              // 後に定義
```

この順序だと、`/users/me`へのリクエストが`/users/{userId}`にマッチし、`userId = "me"`として解釈される。`{userId}`リソースにはGETのみ定義されていたため、PUTリクエストは403となった。

### 解決方法
`api-stack.ts`でリソース定義順序を変更

```typescript
// 修正後
// NOTE: 固定パス 'me' は変数パス '{userId}' より先に定義する必要がある
const meResource = usersResource.addResource('me');              // 先に定義
meResource.addMethod('PUT', ...);

const userByIdResource = usersResource.addResource('{userId}');  // 後に定義
userByIdResource.addMethod('GET', ...);
```

### 教訓
- API Gatewayでは固定パスを変数パスより先に定義する
- 新しいエンドポイント追加時は、既存のルート定義順序を確認する

---

## 4. App ID設定APIの未実装

### 発生日
2026-02-05

### 症状
- オンボーディングでApp IDを設定しても、再ログイン時に再度オンボーディング画面が表示される
- App ID設定時に401エラー（後にToken種類問題と判明）

### 原因
1. フロントエンドの`set-app-id.tsx`にTODOコメントがあり、実際のAPI呼び出しが実装されていなかった
2. バックエンドに`PUT /users/me/app-id`エンドポイントが存在しなかった
3. ローカルストアのみ更新していたため、DynamoDBにappIdが保存されなかった

```typescript
// 問題のあるコード（set-app-id.tsx）
try {
  // TODO: Implement actual API call to set app ID
  await new Promise((resolve) => setTimeout(resolve, 1000));  // ダミー処理
  updateUser({ appId });  // ローカルストアのみ更新
  router.push('/(auth)/set-profile');
}
```

### 解決方法

1. **バックエンドにLambda関数を追加** (`lambda/users/set-app-id.ts`)
```typescript
export const handler: APIGatewayProxyHandler = async (event) => {
  // appIdのバリデーション
  // 既存appIdの確認（変更不可）
  // 重複チェック（GSI1_AppIdを使用）
  // DynamoDBに保存
};
```

2. **API Gatewayにルートを追加** (`api-stack.ts`)
```typescript
const appIdResource = meResource.addResource('app-id');
appIdResource.addMethod('PUT', new apigateway.LambdaIntegration(setAppIdFn), authorizerOptions);
```

3. **フロントエンドで実際のAPIを呼び出し** (`set-app-id.tsx`)
```typescript
const setAppIdMutation = useSetAppId();

const handleContinue = async () => {
  await setAppIdMutation.mutateAsync({ appId });
  router.push('/(auth)/set-profile');
};
```

### 教訓
- TODOコメントは早期に実装する
- フロントエンドとバックエンドの実装状況を同期させる

---

## 5. Cognito AuthorizerのToken種類

### 発生日
2026-02-05

### 症状
- 認証済みなのに401 Unauthorizedエラー
- Lambda関数に到達しない（CloudWatch Logsに記録なし）

### エラーメッセージ
```
[API] Error response: {"data": {"message": "Unauthorized"}, "status": 401, ...}
```

### 原因
- API GatewayのCognitoUserPoolsAuthorizerは**ID Token**を期待
- フロントエンドは**Access Token**を送信していた

```typescript
// 問題のあるコード（useAuth.ts）
onSuccess: (data) => {
  setAuth(data.user, data.accessToken, data.refreshToken);  // Access Tokenを保存
}
```

### 解決方法

1. **ログイン時にID Tokenを保存** (`useAuth.ts`)
```typescript
onSuccess: (data) => {
  // API GatewayのCognitoUserPoolsAuthorizerはID Tokenを期待するため、idTokenを使用
  setAuth(data.user, data.idToken, data.refreshToken);
}
```

2. **トークンリフレッシュ時もID Tokenを使用** (`api.ts`)
```typescript
const { idToken: newIdToken, refreshToken: newRefreshToken } = response.data.data;
useAuthStore.getState().setAuth(currentUser, newIdToken, newRefreshToken);
```

### Access Token vs ID Token

| 項目 | Access Token | ID Token |
|------|-------------|----------|
| 用途 | APIへのアクセス認可 | ユーザー認証・属性情報 |
| 含まれる情報 | スコープ、権限 | ユーザー属性（email等） |
| API Gateway Cognito Authorizer | 使用不可 | **使用可能** |

### 教訓
- API GatewayのCognitoUserPoolsAuthorizerを使用する場合は、ID Tokenを送信する
- Cognitoが返す3種類のトークン（Access, ID, Refresh）の違いを理解する

---

## 6. DynamoDB GSI名・属性名の不一致

### 発生日
2026-02-05

### 症状
- プロフィール画面を開くと「サーバーエラー」が表示される
- フォロー一覧を開くとレンダーエラーが発生する

### エラーメッセージ
```
ValidationException: The table does not have the specified index: followingId-index
```

### 原因
Lambda関数で使用しているDynamoDBのGSI名・属性名が、実際のテーブル定義と一致していなかった。

| Lambda関数での記述 | 実際のテーブル定義 |
|-------------------|-------------------|
| `followingId-index` | `GSI1_Followers` |
| `followingId` | `followeeId` |

### 解決方法
複数のLambda関数を修正

```typescript
// 変更前
queryItems<Follow>({
  TableName: TABLES.FOLLOWS,
  IndexName: 'followingId-index',
  KeyConditionExpression: 'followingId = :userId',
  ...
});

// 変更後
queryItems<Follow>({
  TableName: TABLES.FOLLOWS,
  IndexName: 'GSI1_Followers',
  KeyConditionExpression: 'followeeId = :userId',
  ...
});
```

### 影響を受けたファイル
- `lambda/users/get-profile.ts`
- `lambda/follows/get-following.ts`
- `lambda/follows/get-followers.ts`
- `lambda/follows/follow-user.ts`
- `lambda/follows/unfollow-user.ts`
- `lambda/blocks/block-user.ts`
- `lambda/answers/get-timeline.ts`
- `lambda/answers/get-user-answers.ts`
- `lambda/workflows/delete-user-data.ts`

### 教訓
- Lambda関数を実装する際は、`database-stack.ts`のテーブル定義を必ず確認する
- GSI名・属性名は一貫した命名規則を使用する

---

## 7. queryItems関数がCOUNTに非対応

### 発生日
2026-02-05

### 症状
- フォロワー数・フォロー数が常に0になる

### 原因
`queryItems`関数は`result.Items`を返すが、`Select: 'COUNT'`を使用すると`Items`は空配列になり、代わりに`result.Count`にカウント結果が入る。

```typescript
// 問題のあるコード
const followers = await queryItems<Follow>({
  TableName: TABLES.FOLLOWS,
  IndexName: 'GSI1_Followers',
  KeyConditionExpression: 'followeeId = :userId',
  ExpressionAttributeValues: { ':userId': targetUserId },
  Select: 'COUNT',  // これを指定するとItemsが空になる
});
// followers.length は常に 0
```

### 解決方法
`common/dynamodb.ts`に`queryCount`関数を追加

```typescript
export async function queryCount(params: Omit<QueryCommandInput, 'Select'>): Promise<number> {
  const result = await docClient.send(new QueryCommand({
    ...params,
    Select: 'COUNT',
  }));
  return result.Count || 0;
}
```

使用側を修正：
```typescript
// 変更後
const [followerCount, followingCount] = await Promise.all([
  queryCount({
    TableName: TABLES.FOLLOWS,
    IndexName: 'GSI1_Followers',
    KeyConditionExpression: 'followeeId = :userId',
    ExpressionAttributeValues: { ':userId': targetUserId },
  }),
  queryCount({
    TableName: TABLES.FOLLOWS,
    KeyConditionExpression: 'followerId = :userId',
    ExpressionAttributeValues: { ':userId': targetUserId },
  }),
]);
```

### 教訓
- DynamoDB Queryの`Select`オプションの挙動を理解する
- `Select: 'COUNT'`使用時は`Items`ではなく`Count`を参照する

---

## 8. APIレスポンス形式の不一致

### 発生日
2026-02-05

### 症状
- フォロー一覧画面でレンダーエラーが発生
- プロフィール画面でデータが表示されない

### 原因
バックエンドとフロントエンドでレスポンス形式が異なっていた。

**例1: フォロー一覧**
```typescript
// バックエンドが返していた形式
{ users: [...] }

// フロントエンドが期待していた形式
{ items: [...], nextCursor?: string }
```

**例2: プロフィール取得**
```typescript
// バックエンドが返していた形式
{ user: { userId, displayName, ... } }

// フロントエンドが期待していた形式
{ userId, displayName, ... }
```

### 解決方法
バックエンドのレスポンス形式をAPI設計書に合わせて修正

```typescript
// 変更前
return success({ users: result });

// 変更後
return success({ items: result });
```

### 教訓
- API設計書のレスポンス形式を厳守する
- フロントエンドの型定義とバックエンドのレスポンスを一致させる

---

## 9. S3バケットのパブリックアクセス設定

### 発生日
2026-02-05

### 症状
- プロフィール画像をアップロードできる
- プロフィール画面で画像が真っ黒（表示されない）

### 原因
S3バケットが`BlockPublicAccess.BLOCK_ALL`で設定されており、画像URLに直接アクセスできなかった。

```typescript
// storage-stack.ts
this.profileImageBucket = new s3.Bucket(this, 'ProfileImageBucket', {
  blockPublicAccess: s3.BlockPublicAccess.BLOCK_ALL,  // すべてのパブリックアクセスをブロック
  ...
});
```

### 確認方法
```bash
# バケットのパブリックアクセス設定を確認
aws s3api get-public-access-block --bucket dev-q-profile-images-XXXX

# 画像URLへのアクセスを確認
curl -I "https://bucket-name.s3.amazonaws.com/path/to/image.jpg"
# 403 Forbiddenが返る場合はアクセス拒否されている
```

### 解決方法
`storage-stack.ts`でパブリック読み取りを許可

```typescript
this.profileImageBucket = new s3.Bucket(this, 'ProfileImageBucket', {
  blockPublicAccess: new s3.BlockPublicAccess({
    blockPublicAcls: false,
    ignorePublicAcls: false,
    blockPublicPolicy: false,
    restrictPublicBuckets: false,
  }),
  publicReadAccess: true,  // パブリック読み取りを許可
  ...
});
```

### 備考
- 本番環境ではCloudFrontを使用し、署名付きURLでアクセスする方がセキュア
- 開発環境ではパブリック読み取りで問題なし

---

## 10. プロフィール画像削除APIの未実装

### 発生日
2026-02-05

### 症状
- プロフィール編集画面で「写真を削除」ボタンを押すと「操作を行う権限がありません」エラー

### エラーメッセージ
```
AxiosError: Request failed with status code 403
この操作を行う権限がありません。
```

### 原因
- フロントエンドは`DELETE /users/me/profile-image`を呼び出していた
- バックエンドにこのエンドポイントが存在しなかった
- API Gatewayで未定義のエンドポイントにアクセスすると403が返る

### 解決方法

1. **Lambda関数を作成** (`lambda/users/delete-profile-image.ts`)
```typescript
export const handler: APIGatewayProxyHandler = async (event) => {
  // 1. ユーザープロフィールを取得
  // 2. S3から画像を削除
  // 3. DynamoDBのprofileImageUrlをREMOVE
  return success({ message: 'Profile image deleted successfully' });
};
```

2. **API Stackにエンドポイントを追加** (`api-stack.ts`)
```typescript
// Lambda関数を定義
const deleteProfileImageFn = new NodejsFunction(this, 'DeleteProfileImageFunction', {
  ...nodeJsFunctionProps,
  entry: path.join(lambdaDir, 'users/delete-profile-image.ts'),
  handler: 'handler',
  functionName: `${prefix}-users-delete-profile-image`,
});
tables.users.grantReadWriteData(deleteProfileImageFn);
profileImageBucket.grantDelete(deleteProfileImageFn);

// DELETEメソッドを追加
profileImageResource.addMethod(
  'DELETE',
  new apigateway.LambdaIntegration(deleteProfileImageFn),
  authorizerOptions
);
```

### 教訓
- フロントエンドで使用しているAPIエンドポイントがすべてバックエンドに存在するか確認する
- API設計書に基づいて実装漏れをチェックする

---

## 11. 管理画面ログインAPIのレスポンス形式

### 発生日
2026-02-05

### 症状
- 管理画面でログインしようとすると「Cannot read properties of undefined (reading 'userId')」エラー
- 認証は成功しているがユーザー情報が取得できない

### 原因
バックエンドのログインAPIは `{ data: { user: {...}, accessToken: ... } }` 形式で返すが、フロントエンドの auth.ts は `response.data` でアクセスしていた。

```typescript
// バックエンドの実際のレスポンス
{ data: { user: {...}, accessToken: ..., idToken: ... } }

// フロントエンドが期待していた形式
{ user: {...}, accessToken: ..., idToken: ... }
```

### 解決方法
`apps/admin/src/services/auth.ts` でレスポンスの展開を修正

```typescript
// 変更前
return response.data;

// 変更後
return response.data.data;
```

また、`api.ts`のレスポンスインターセプターで自動展開を追加：
```typescript
apiClient.interceptors.response.use(
  (response) => {
    if (response.data && 'data' in response.data) {
      response.data = response.data.data;
    }
    return response;
  },
  ...
);
```

### 教訓
- バックエンドの `success()` 関数は `{ data: {...} }` でラップすることを忘れない
- フロントエンドとバックエンドのレスポンス形式を統一する

---

## 12. 管理画面APIレスポンス形式の不統一

### 発生日
2026-02-05

### 症状
- NGワード一覧、お題一覧などが空で表示される
- APIは200で成功しているがデータが表示されない

### 原因
各管理APIが異なるキー名でレスポンスを返していた：
- `list-ng-words.ts`: `{ ngWords: [...] }`
- `list-questions.ts`: `{ questions: [...] }`
- `list-reports.ts`: `{ reports: [...] }`

フロントエンドは `{ items: [...] }` を期待していた。

### 解決方法
すべての一覧APIで `items` キーを使用するように統一

```typescript
// 変更前
return success({ ngWords: ngWords.map(...) });

// 変更後
return success({ items: ngWords.map(...) });
```

また、`success()` 関数を使わずに直接JSONを返していたAPIも統一：
```typescript
// 変更前
return {
  statusCode: 200,
  body: JSON.stringify({ items: users }),
};

// 変更後
return success({ items: users });
```

### 教訓
- API設計書でレスポンス形式を明確に定義する
- 一覧APIは `{ items: [...], nextCursor?: string }` で統一する

---

## 13. NGワードテーブルのキースキーマ

### 発生日
2026-02-05

### 症状
- NGワード削除時に「The provided key element does not match the schema」エラー

### エラーメッセージ
```
ValidationException: The provided key element does not match the schema
```

### 原因
`delete-ng-word.ts`で `{ Key: { wordId } }` を使用していたが、実際のテーブルのパーティションキーは `word`（NGワード文字列自体）だった。

```typescript
// 問題のあるコード
await deleteItem({
  TableName: TABLES.NG_WORDS,
  Key: { wordId },  // ← 存在しないキー
});

// 実際のテーブル定義（database-stack.ts）
const ngWordsTable = new dynamodb.Table(this, 'NGWordsTable', {
  partitionKey: { name: 'word', type: dynamodb.AttributeType.STRING },
});
```

### 解決方法
キーを `word` に変更し、一覧APIでは `wordId` として `word` の値を返すように修正

```typescript
// delete-ng-word.ts
await deleteItem({
  TableName: TABLES.NG_WORDS,
  Key: { word },  // wordをキーとして使用
});

// list-ng-words.ts
return success({
  items: ngWords.map((w) => ({
    wordId: w.word,  // フロントエンドはwordIdとして扱う
    word: w.word,
    createdAt: w.createdAt,
  })),
});
```

### 教訓
- Lambda実装時は必ずテーブル定義（database-stack.ts）を確認する
- キースキーマを理解してから実装する

---

## 14. URLエンコーディング（日本語対応）

### 発生日
2026-02-05

### 症状
- NGワードの削除がLambdaでは成功するがDynamoDBからは削除されない
- 日本語のNGワードを削除しようとすると実際には削除されない

### 原因
フロントエンドはURLエンコードしてリクエストを送信するが、Lambda側でデコードしていなかった。

```
// フロントエンドが送信するURL
DELETE /admin/ng-words/%E3%83%86%E3%82%B9%E3%83%88  ← "テスト"がエンコードされた

// Lambda側で受け取る値
event.pathParameters.wordId = "%E3%83%86%E3%82%B9%E3%83%88"  ← エンコードされたまま

// DynamoDBで検索しようとする値
Key: { word: "%E3%83%86%E3%82%B9%E3%83%88" }  ← マッチしない
```

### 解決方法

1. **フロントエンドでURLエンコード**（`useAdminApi.ts`）
```typescript
await apiClient.delete(`/admin/ng-words/${encodeURIComponent(wordId)}`);
```

2. **Lambda側でURLデコード**（`delete-ng-word.ts`）
```typescript
const rawWord = event.pathParameters?.wordId;
const word = decodeURIComponent(rawWord);
```

### 教訓
- パスパラメータに日本語などのマルチバイト文字が含まれる場合はエンコード/デコードが必要
- API GatewayはURLデコードを自動で行わない場合がある

---

## 15. 質問公開時刻が要件と異なる（固定時刻になっていた）

### 発生日
2026-02-05

### 症状
- 通知設定画面に「毎日14:30頃に今日の質問をお知らせします」と表示されていた
- 実際の実装もEventBridgeで固定時刻（7:00 JST）にプッシュ通知を送信していた

### 要件定義書の仕様
```
2.1 日次仕様
- 通知/公開タイミング：毎日10:00〜21:00の間でランダム。

2.2 公開/判定
- 公開時刻は「毎日0:00に乱数で決定してDBに保存」する
```

### 原因
1. **要件定義書と実装の同期不足**: 要件定義書の仕様を実装時に確認しなかった
2. **設計書の参照不足**: DB設計書には `scheduledPublishTime` と `publishedAt` が設計されていたのに、実装時に参照されなかった
3. **暫定実装の放置**: スケジューラー実装時に固定時刻で仮実装したまま、本来の仕様に戻されなかった
4. **フェーズ完了時の仕様確認不足**: フェーズ3完了時に、要件定義書との突き合わせが行われなかった

### 解決方法

**1. `publish-daily-question.ts` を修正**
- 毎日0:00にランダムな公開時刻（10:00〜21:00）を決定し、`scheduledPublishTime` として保存

**2. 新規に `check-and-publish.ts` を作成**
- 10分おきに実行（10:00〜21:00 JST）
- 公開時刻に達したら `publishedAt` をセットし、プッシュ通知を送信

**3. `get-daily-question.ts` を修正**
- `publishedAt` がセットされていない場合は質問を返さない（未公開状態）

**4. `scheduler-stack.ts` を修正**
- 固定時刻の通知スケジュールを削除
- 10分おきのチェックスケジュールを追加

**5. アプリ側の対応**
- 未公開状態のレスポンスを処理し、公開予定時刻を表示

### 教訓
- **実装前に必ず要件定義書の該当セクションを読む**
- **実装後に要件定義書とのdiff確認を行う**
- **フェーズ完了時のチェックリストに「要件定義書との照合」を追加**
- **DB設計書に定義されているフィールドは、必ず実装に反映する**

---

## デバッグのヒント

### 1. フロントエンドのログ確認
```typescript
// api.ts にデバッグログを追加
console.log('[API]', config.method?.toUpperCase(), config.url);
console.log('[API] Token exists:', !!token);
console.log('[API] Error response:', error.response?.data);
```

### 2. Lambda関数のログ確認
```bash
aws logs tail /aws/lambda/<function-name> --since 10m --format short
```

### 3. API Gatewayの問題切り分け
- Lambdaに到達していない → Authorizer or ルート定義の問題
- Lambdaに到達している → Lambda内部の問題

### 4. CDKデプロイ後の確認
```bash
# スタック一覧
npm run cdk list

# 特定スタックのデプロイ
npm run cdk deploy dev-q-api -- --require-approval never
```

---

## 更新履歴

| 日付 | 内容 |
|------|------|
| 2026-02-05 | 初版作成 |
| 2026-02-05 | #6〜#10 追加（DynamoDB GSI、queryCount、レスポンス形式、S3パブリックアクセス、画像削除API） |
